import type * as express from 'express'
import type { AppLoadContext } from 'react-router'
import * as ReactRouter from 'react-router'

import * as ReactRouterNode from '../react-router-node/index.ts'

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by Express middleware like `req.session`.
 */
export type GetLoadContextFunction = (
	req: express.Request,
	res: express.Response,
) => Promise<ReactRouter.AppLoadContext> | ReactRouter.AppLoadContext

export type RequestHandler = (
	req: express.Request,
	res: express.Response,
	next: express.NextFunction,
) => Promise<void>

/**
 * Creates a request handler for processing HTTP requests and responses using Remix.
 *
 * @param options - Configuration options for the request handler.
 * @param options.build - The server build object or a function that returns a server build object for Remix.
 * @param options.getLoadContext - An optional function to provide additional load context based on the incoming request and response.
 * @param options.mode - The mode in which the application is running, e.g., 'development', 'production'. Defaults to the value of the NODE_ENV environment variable.
 * @return The constructed request handler function for use with Express.
 */
export function createRequestHandler({
	build,
	getLoadContext,
	mode = process.env['NODE_ENV'],
}: {
	build: ReactRouter.ServerBuild | (() => Promise<ReactRouter.ServerBuild>)
	getLoadContext?: GetLoadContextFunction
	mode?: string
}): RequestHandler {
	const handleRequest = ReactRouter.createRequestHandler(build, mode)

	return async (
		req: express.Request,
		res: express.Response,
		next: express.NextFunction,
	): Promise<void> => {
		try {
			const request: Request = createRemixRequest(req, res)
			const loadContext: AppLoadContext | undefined = await getLoadContext?.(
				req,
				res,
			)

			const response: Response = await handleRequest(request, loadContext)

			await sendRemixResponse(res, response)
		} catch (error: unknown) {
			/**
			 * Express doesn't support async functions, so we have to pass along the
			 * error manually using next().
			 */
			next(error)
		}
	}
}

function createRemixHeaders(
	requestHeaders: express.Request['headers'],
): Headers {
	const headers = new Headers()

	for (const [key, values] of Object.entries(requestHeaders)) {
		if (values) {
			if (Array.isArray(values)) {
				for (const value of values) {
					headers.append(key, value)
				}
			} else {
				headers.set(key, values)
			}
		}
	}

	return headers
}

/**
 * Creates a new Remix Request object based on the given Express request and response objects.
 *
 * This method resolves the full URL of the incoming request using information from the Express request object, including the protocol, hostname, port, and original URL. It also sets up an `AbortController` to abort Remix actions or loaders if the response is no longer writable (e.g., when the client connection is closed or the response is finished). Additionally, it correctly handles request methods other than `GET` and `HEAD` by creating a readable stream for the request body.
 *
 * @param req The Express request object containing details about the HTTP request.
 * @param res The Express response object used to monitor connection state and response status.
 * @return Returns a Remix `Request` object that represents the HTTP request in a format compatible with the Remix framework.
 */
function createRemixRequest(
	req: express.Request,
	res: express.Response,
): Request {
	/**
	 * req.hostname doesn't include port information so grab that from
	 * `X-Forwarded-Host` or `Host`
	 */
	const [, hostnamePort] = req.get('X-Forwarded-Host')?.split(':') ?? []
	const [, hostPort] = req.get('host')?.split(':') ?? []
	const port = hostnamePort || hostPort
	/**
	 * Use req.hostname here as it respects the "trust proxy" setting
	 */
	const resolvedHost = `${req.hostname}${port ? `:${port}` : ''}`
	/**
	 * Use `req.originalUrl` so Remix is aware of the full path
	 */
	const url = new URL(`${req.protocol}://${resolvedHost}${req.originalUrl}`)

	/**
	 * Abort action/loaders once we can no longer write a response
	 */
	let controller: AbortController | null = new AbortController()
	const init: RequestInit = {
		method: req.method,
		headers: createRemixHeaders(req.headers),
		signal: controller.signal,
	}

	/**
	 * Abort action/loaders once we can no longer write a response iff we have
	 * not yet sent a response (i.e., `close` without `finish`)
	 * `finish` -> done rendering the response
	 * `close` -> response can no longer be written to
	 */
	res.on('finish', () => {
		controller = null
	})
	res.on('close', () => controller?.abort())

	if (req.method !== 'GET' && req.method !== 'HEAD') {
		init.body = ReactRouterNode.createReadableStreamFromReadable(req)
		;(init as { duplex: 'half' }).duplex = 'half'
	}

	return new Request(url.href, init)
}

/**
 * Sends a Remix response from a given `Response` object to an Express.js `Response`.
 *
 * @param res - The Express.js response object to which the Remix response will be written.
 * @param nodeResponse - The Remix response object containing status, headers, and body to transfer.
 * @return A promise resolving when the response has been fully sent.
 */
async function sendRemixResponse(
	res: express.Response,
	nodeResponse: Response,
): Promise<void> {
	res.statusMessage = nodeResponse.statusText
	res.status(nodeResponse.status)

	for (const [key, value] of nodeResponse.headers.entries()) {
		res.append(key, value)
	}

	if (nodeResponse.headers.get('Content-Type')?.match(/text\/event-stream/i)) {
		res.flushHeaders()
	}

	if (nodeResponse.body) {
		await ReactRouterNode.writeReadableStreamToWritable(nodeResponse.body, res)
	} else {
		res.end()
	}
}
